 Secure Password Hashing & Authentication System
A robust Python implementation for secure password storage and user authentication using industry-standard cryptographic hashing algorithms. This project demonstrates best practices for protecting user credentials by converting plain-text passwords into irreversible hash strings.
ğŸ¯ Overview
This system provides a complete solution for secure password management, implementing cryptographic hashing to ensure that passwords are never stored in plain text. The hash outputs are generated as strings, making them easy to store in any database system while maintaining maximum security.
âœ¨ Features

ğŸ›¡ï¸ Secure Hashing: Uses PBKDF2-SHA256 algorithm with automatic salt generation
ğŸ”’ One-Way Encryption: Passwords cannot be reversed from their hash values
âœ… Easy Authentication: Simple verification method for login systems
ğŸ’¾ String-Based Storage: Hash outputs as strings ready for database integration
ğŸš€ Production-Ready: Implements OWASP and NIST security recommendations
ğŸ“¦ Lightweight: Minimal dependencies with the reliable Passlib library

ğŸ”§ Installation
bashpip install passlib
ğŸš€ Quick Start
pythonfrom passlib.hash import pbkdf2_sha256

# Hash a password
password = "MySecurePassword123!"
hashed = pbkdf2_sha256.hash(password)
print(f"Hashed: {hashed}")

# Verify a password
is_valid = pbkdf2_sha256.verify("MySecurePassword123!", hashed)
print(f"Authentication: {is_valid}")  # True

# Wrong password
is_valid = pbkdf2_sha256.verify("WrongPassword", hashed)
print(f"Authentication: {is_valid}")  # False
ğŸ“– Usage Examples
Basic Password Management
pythonfrom passlib.hash import pbkdf2_sha256

class PasswordManager:
    @staticmethod
    def hash_password(password):
        """Hash a password for storing."""
        return pbkdf2_sha256.hash(password)
    
    @staticmethod
    def verify_password(password, hashed_password):
        """Verify a stored password against one provided by user."""
        return pbkdf2_sha256.verify(password, hashed_password)

# Usage
pm = PasswordManager()
stored_hash = pm.hash_password("user_password_123")
print(pm.verify_password("user_password_123", stored_hash))  # True
Multi-User System
python# Simulating user database
users_db = {}

def register_user(username, password):
    """Register a new user with hashed password."""
    users_db[username] = pbkdf2_sha256.hash(password)
    print(f"User '{username}' registered successfully!")

def authenticate_user(username, password):
    """Authenticate a user."""
    if username not in users_db:
        return False
    return pbkdf2_sha256.verify(password, users_db[username])

# Register users
register_user("alice", "alice_secure_pass")
register_user("bob", "bob_password_2024")

# Authenticate
print(authenticate_user("alice", "alice_secure_pass"))  # True
print(authenticate_user("alice", "wrong_password"))      # False
ğŸ” Security Features
Why This Approach is Secure

One-Way Hashing: Impossible to reverse the hash back to the original password
Automatic Salting: Each password gets a unique random salt to prevent rainbow table attacks
Computational Complexity: 29,000 iterations make brute-force attacks impractical
Industry Standards: Implements PBKDF2-SHA256, recommended by NIST and OWASP

Hash String Format
$pbkdf2-sha256$29000$randomsalt$actualhashvalue
â”‚       â”‚        â”‚        â”‚            â”‚
â”‚       â”‚        â”‚        â”‚            â””â”€ Computed hash
â”‚       â”‚        â”‚        â””â”€ Unique salt (prevents identical hashes)
â”‚       â”‚        â””â”€ Iteration count (computational cost)
â”‚       â””â”€ Algorithm identifier
â””â”€ Format marker
Example Hash Output:
$pbkdf2-sha256$29000$N2bMuZdSSmktxVjLuf.f8w$qXt5.PJhoQXgXgGXdz8KI4kMgdHHGZJ0YCzKJPH5e1s
